@startuml

'extractor interface information

interface Nested

interface Node
Node --|> Nested

interface Nodes
Nodes --|> Nested

interface NodeC
NodeC --|> Nested

interface Type
Type --|> Nested



abstract Class UniqueEntity {
+ uuid: UUID
}

abstract Class InputEntity
InputEntity --|> UniqueEntity

Interface Operable {
+ inOperation: Boolean
}

abstract Class AssetInput {
- id: String
- operationTime: OperationTime
- operator: OperatorInput
}
AssetInput --|> InputEntity
AssetInput --|> Operable

abstract Class SystemParticipantInput {
- node: NodeInput
- qCharacteristics: String
}
SystemParticipantInput --|> AssetInput
SystemParticipantInput --|> Node

Class OperatorInput {
+ name: String
}
OperatorInput --|> InputEntity

abstract Class ConnectorInput {
+ nodeA: NodeInput
+ nodeB: NodeInput
}
ConnectorInput --|> AssetInput
ConnectorInput --|> Nodes

abstract Class AssetCharacteristicsInput<T extends AssetTypeInput> {
    - type: T
    - characteristic: String
}
AssetCharacteristicsInput --|> InputEntity

Class WecCharacteristicInput {
}
WecCharacteristicInput --|> AssetCharacteristicsInput: <<bind>>T::WecTypeInput

Class EvCharacteristicInput {
}
EvCharacteristicInput --|> AssetCharacteristicsInput: <<bind>>T::EvTypeInput

abstract Class AssetTypeInput {
+ id: String
}
AssetTypeInput --|> InputEntity

abstract Class SystemParticipantTypeInput {
- capex: Quantity<Currency> [€]
- opex: Quantity<EnergyPrice> [€/MWh]
- sRated: Quantity<Power> [kVA]
- cosphiRated: Double
}
SystemParticipantTypeInput --|> AssetTypeInput



Class BmTypeInput {
   - etaConv: Quantity<Dimensionless> [%]
   - loadGradient: Quantity<DimensionlessRate> [%/h]
}
BmTypeInput --|> SystemParticipantTypeInput

Class ChpTypeInput {
    - pEl: Quantity<Quantity<Power>> [kW]
    - pThermal: Quantity<Quantity<Power>> [KW]
    - etaEl: Quantity<Dimensionless> [%]
    - etaTh: Quantity<Dimensionless> [%]
    - pOwn: Quantity<Quantity<Power>> [kW]
    - thermalStorage: ThermalStorageInput
 }
ChpTypeInput --|> SystemParticipantTypeInput

Class EvTypeInput {
    - eStorage: Quantity<Energy> [kWh]
    - sRated: Quantity<Power> [kVA]
    - eCons: Quantity<SpecificEnergy> [kWh/km]
}
EvTypeInput --|> SystemParticipantTypeInput


Class HpTypeInput {
    - ethLosses: Quantity<ThermalConductance> [kW/K]
    - ethCapa: Quantity<Energy> [kWh]
    - sRated: Quantity<Power> [kVA]
    - pThermal: Quantity<Power> [kW]
    - pEl: Quantity<Power> [kW]
}
HpTypeInput --|> SystemParticipantTypeInput


Class StorageTypeInput {
- sRated: Quantity<Power> [kVA]
- pMin: Quantity<Power>[kW]
- pMax: Quantity<Power> [kW]
- eta: Quantity<Dimensionless> [%]
- eStorage: Quantity<Energy> [kWh]
- dod: Quantity<Dimensionless> [%]
- lifeTime: Quantity<Time> [ms]
- lifeCycle: Integer
}
StorageTypeInput --|> SystemParticipantTypeInput

Class WecTypeInput {
- rotorArea: Quantity<Area> [m²]
- hubHeight: Quantity<Length> [m]
- etaConv: Quantity<Dimensionless> [%]
}
WecTypeInput --|> SystemParticipantTypeInput


Class LineTypeInput {
+ r: Quantity<SpecificResistance> (Ohm/km)
+ x: Quantity<SpecificResistance> (Ohm/km)
+ g: Quantity<SpecificConductance> (µS/km)
+ b: Quantity<SpecificConductance> (µS/km)
+ iMax: Quantity<ElectricCurrent> (A)
+ vRated: Quantity<ElectricPotential> (V)
+ olmChar: Optional<String>
}
LineTypeInput --|> AssetTypeInput

Class Transformer2WTypeInput {
+ sRated: Quantity<Power> (MVA)
+ vRatedA: Quantity<ElectricPotential> (kV)
+ vRatedB: Quantity<ElectricPotential> (kV)
+ rSc: Quantity<ElectricalResistance> (Ohm)
+ xSc: Quantity<ElectricalResistance> (Ohm)
+ gM: Quantity<ElectricalConductance> (nS)
+ bM: Quantity<ElectricalConductance> (nS)
+ dV: Quantity<Dimensionless> (%)
+ dPhi: Quantity<Angle> (Degrees)
+ tapSide: Boolean
+ tapNeutr: Integer
+ tapMin: Integer
+ tapMax: Integer
}
Transformer2WTypeInput --|> AssetTypeInput

Class Transformer3WTypeInput {
+ vRatedA: Quantity<ElectricPotential> (kV)
+ vRatedB: Quantity<ElectricPotential> (kV)
+ vRatedC: Quantity<ElectricPotential> (kV)
+ rScA: Quantity<ElectricalResistance> (Ohm)
+ rScB: Quantity<ElectricalResistance> (Ohm)
+ rScC: Quantity<ElectricalResistance> (Ohm)
+ xScA: Quantity<ElectricalResistance> (Ohm)
+ xScB: Quantity<ElectricalResistance> (Ohm)
+ xScC: Quantity<ElectricalResistance> (Ohm)
+ gM: Quantity<ElectricalConductance> (nS)
+ bM: Quantity<ElectricalConductance> (nS)
+ sRatedA: Quantity<Power> (MVA)
+ sRatedB: Quantity<Power> (MVA)
+ sRatedC: Quantity<Power> (MVA)
+ dV: Quantity<Dimensionless> (%)
+ dPhi: Quantity<Angle> (Degrees)
+ tapNeutr: Integer
+ tapMin: Integer
+ tapMax: Integer
}
Transformer3WTypeInput --|> AssetTypeInput

Class RandomLoadParameter {
+ quarterHour: Integer
+ kWd: Double
+ kSa: Double
+ kSu: Double
+ myWd: Double
+ mySa: Double
+ mySu: Double
+ sigmaWd: Double
+ sigmaSa: Double
+ sigmaSu: Double
}
RandomLoadParameter --|> InputEntity

Class FixedFeedInInput {
- sRated: Quantity<Power> [kVA]
- cosphiRated: double
}
FixedFeedInInput --|> SystemParticipantInput

Class PvInput {
- sRated: Quantity<Power> [kVA]
- cosphiRated: double
- azimuth: Quantity<Angle> [Degrees]
- solarHeight: Quantity<Angle> [Degrees]
- etaConv: Quantity<Dimensionless> [%]
- albedo: Double
- kG: Double
- kT: Double
- marketReaction: Boolean
}
PvInput --|> SystemParticipantInput

Class WecInput{
- type: WecTypeInput
- marketReaction: Boolean
}
WecInput --|> SystemParticipantInput
WecInput --|> Type

Class ChpInput {
- type: ChpTypeInput
- marketReaction: Boolean
}
ChpInput --|> SystemParticipantInput
ChpInput --|> Type

Class BmInput {
- type: BmTypeInput
- sRated: Quantity<Power> [KW]
- feedInTariff: Quantity<SpecificCurrency> [€/kWh]
- marketReaction: Boolean
- costControlled: Boolean
}
BmInput --|> SystemParticipantInput
BmInput --|> Type

Class EvInput {
- type: EvTypeInput
}
EvInput --|> SystemParticipantInput
EvInput --|> Type

Class LoadInput {
- scenario: String
- sRated: Quantity<Power> [kVA]
- eConsAnnual: Quantity<Energy> [kWh]
- dsm: Boolean
}
LoadInput --|> SystemParticipantInput

Class StorageInput {
- type: StorageTypeInput
- behaviour: String
}
StorageInput --|> SystemParticipantInput
StorageInput --|> Type

Class HpInput {
- type: HpTypeInput
}
HpInput --|> SystemParticipantInput
HpInput --|> Type

Abstract Class ThermalUnitInput {
 - uuid: UUID
 - bus: ThermalBusInput
}
ThermalUnitInput --|> AssetInput

Class ThermalBusInput {
}
ThermalBusInput --|> AssetInput

Abstract Class ThermalSinkInput {
}
ThermalSinkInput --|> ThermalUnitInput

Class ThermalHouseInput {
 - ethCapa: Quantity<HeatCapacity> [kWh / K]
 - ethLosses: Quantity<ThermalConductance> [kW / K]
}
ThermalHouseInput --|> ThermalSinkInput

Abstract Class ThermalStorageInput {
}
ThermalStorageInput --|> ThermalUnitInput

Class CylindricalStorage {
  - storageVolumeLvl: Quantity<Volume>
  - storageVolumeLvlMin: Quantity<Volume>
  - inletTemp: Quantity<Temperature>
  - returnTemp: Quantity<Temperature>
  - c: Quantity<SpecificHeatCapacity>
}
CylindricalStorage --|> ThermalStorageInput

Class MeasurementUnitInput {
+ node: NodeInput
+ vMag: Boolean [default f]
+ vAng: Boolean [default f]
+ p: Boolean [default f]
+ q: Boolean [default f]
}
MeasurementUnitInput --|> AssetInput

Class NodeInput {
+ vTarget: Quantity<Dimensionless> (pU)
+ vRated: Quantity<ElectricPotential> (kV)
+ slack: Boolean
+ geoPosition: Point
+ voltLvl: VoltageLevel
+ subnet: Integer
}
NodeInput --|> AssetInput

Class EvcsInput {
???
}
EvcsInput --|> AssetInput


Class LineInput {
+ type: LineTypeInput
+ length: Quantity<Length> (km)
+ amount: Integer
+ olm: Optional<String>
+ geoPosition: LineString
}
LineInput --|> ConnectorInput
LineInput --|> Type

Class SwitchInput {
+ closed: Boolean
}
SwitchInput --|> ConnectorInput

abstract TransformerInput {
+ tapPos: Integer
+ amount: Integer
+ autoTap: Boolean
}
TransformerInput --|> ConnectorInput

Class Transformer2WInput {
+ type: Transformer2WTypeInput
}
Transformer2WInput --|> TransformerInput
Transformer2WInput --|> Type

Class Transformer3WInput {
+ nodeC: NodeInput
+ type: Transformer3WTypeInput
}
Transformer3WInput --|> TransformerInput
Transformer3WInput --|> NodeC
Transformer3WInput --|> Type

abstract Class GraphicInput {
+ graphicLayer: String
+ path: LineString
}
GraphicInput --|> InputEntity

Class NodeGraphicInput {
+ node: NodeInput
+ point: Point
}
NodeGraphicInput --|> GraphicInput

Class LineGraphicInput {
+ line: LineInput
}
LineGraphicInput --|> GraphicInput

Abstract Class Entry <V extends Value> {
    - value: V
}
Entry --|> UniqueEntity
Entry --* Value

Interface Value

Class LoadProfileEntry {
    - dayOfWeek: DayOfWeek
    - quarterHourOfDay: int
}
LoadProfileEntry --|> Entry: <<bind>>:PValue

abstract Class TimeBasedValue<V extends Value>{
    - time: ZonedDateTime
}
TimeBasedValue --|> Entry: <<bind>>:V

Class PowerValue {
    - p: Quantity<Power> [kW]
    - q: Quantity<Power> [kVA]
}
PowerValue --|> Value

Class HeatAndPowerValue {
    - heatDemand: Quantity<Power> [kW]
}
HeatAndPowerValue --|> PowerValue

Class HeatDemandValue {
    - heatDemand: Quantity<Power> [kW]
}
HeatDemandValue --|> Value

Class EnergyPriceValue {
    - price: Quantity<SpecificCurrency> [€/MWh]
}
EnergyPriceValue --|> Value

Class IrradiationValue {
    - directIrradiation: Quantity<Irradiation>
    - diffuseIrradiation: Quantity<Irradiation>
}
IrradiationValue --|> Value

Class TemperatureValue {
    - temperature: Quantity<Temperature>
}
TemperatureValue --|> Value

Class WindValue {
    - direction: Quantity<Angle>
    - velocity: Quantity<Speed>
}
WindValue --|> Value

Class WeatherValue {
  - coordinate: Point
  - irradiation: IrradiationValue
  - temperature: TemperatureValue
  - wind: WindValue
}
WeatherValue --|> Value
WeatherValue --* IrradiationValue
WeatherValue --* TemperatureValue
WeatherValue --* WindValue

Interface LoadProfileType {
}

enum PowerSystemLoadProfileType {
BL_H
G0_A
G0_M
...
}
PowerSystemLoadProfileType --|> LoadProfileType

Interface VoltageLevel {
}

enum GermanVoltageLevel {
HoeS,
HS,
MS,
NS
}
GermanVoltageLevel --|> VoltageLevel

Abstract Class TimeSeries<E extends Entry<V>, V extends Value> {
    - entries: Set<E>
    + TimeBasedValue<T> getTimeBasedValue(ZonedDateTime)
    + T getValue(ZonedDateTime)
    + Set<E> getEntries()
    - ZonedDateTime getPreviousDateTime()
    - ZonedDateTime getNextDateTime()
}
TimeSeries --|> UniqueEntity
TimeSeries "1" --* "n" Entry

Class IndividualTimeSeries<V extends Value> {
    - Map<ZonedDateTime, TimeBasedValue<V>> timeToValue
}
IndividualTimeSeries --|> TimeSeries: <<bind>>:TimeBasedValue<V>

Abstract Class RepetitiveTimeSeries<T extends Value> {
    - calc(ZonedDateTime): T
}
RepetitiveTimeSeries --|> TimeSeries

Class LoadProfileInput {
    + profile: LoadProfileType
}
LoadProfileInput --|> RepetitiveTimeSeries
LoadProfileInput --> LoadProfileType

@enduml