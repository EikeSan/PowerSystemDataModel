@startuml
note "For better readability no getters are shown in the classes. Also the final attributes are not marked especially." as generalNote

interface Comparable<T>

interface StandardLoadProfile {
    + getKey: String
    + enum DefaultLoadProfiles
    + {static} parse(String): StandardLoadProfile
}

enum BdewLoadProfile {
    - key: String
    + {static} get(String): BdewLoadProfile
}
BdewLoadProfile ..|> StandardLoadProfile

abstract class UniqueEntity {
    + {static} UUID_FIELD_NAME: String
    + uuid: UUID
}

package result {
    abstract class ResultEntity
    UniqueEntity <|-- ResultEntity
}
note left of result : cf. separate UML diagram

package input {
    abstract class InputEntity
    InputEntity --|> UniqueEntity
}

package value {
    interface Value

    class EnergyPriceValue {
        - price: ComparableQuantity<SpecificCurrency> [€/MWh]
    }
    EnergyPriceValue ..|> Value

    class HeatDemandValue {
        - heatDemand : ComparableQuantity<Power> [kW]
    }
    HeatDemandValue ..|> Value

    class PValue {
        - p: ComparableQuantity<Power> [kW]
    }
    PValue ..|> Value

    class HeatAndPValue {
        - heatDemand: ComparableQuantity<Power> [kW]
    }
    HeatAndPValue --|> PValue

    class SValue {
        - q: ComparableQuantity<Power> [kVAr]
    }
    SValue --|> PValue

    class HeatAndSValue {
        - heatDemand: ComparableQuantity<Power> [kW]
    }
    HeatAndSValue --|> SValue

    class IrradiationValue {
      - directIrradiation: ComparableQuantity<Irradiation> [kWh/m²]
      - diffuseIrradiation: ComparableQuantity<Irradiation> [kWh/m²]
    }
    IrradiationValue ..|> Value

    class TemperatureValue {
      - temperature: ComparableQuantity<Temperature> [°C]
    }
    TemperatureValue ..|> Value

    class WindValue {
      - direction: ComparableQuantity<Angle> [°]
      - velocity: ComparableQuantity<Speed> [m/s]
    }
    WindValue ..|> Value

    class WeatherValue {
      - coordinate: Point
      - irradiation: IrradiationValue
      - temperature: TemperatureValue
      - wind: WindValue
    }
    WeatherValue ..|> Value
    WeatherValue *-- IrradiationValue
    WeatherValue *-- TemperatureValue
    WeatherValue *-- WindValue
}

package timeseries {
    abstract class TimeSeries<E extends Entry<V>, V extends Value> {
        - entries: Set<E>
        + Optional<TimeBasedValue<V>> getTimeBasedValue(ZonedDateTime)
        + Optional<V> getValue(ZonedDateTime)
        + Set<E> getEntries()
        + Optional<TimeBasedValue<V>> getPreviousTimeBasedValue(ZonedDateTime)
        + Optional<TimeBasedValue<V>> getNextTimeBasedValue(ZonedDateTime)
        - Optional<ZonedDateTime> getPreviousDateTime()
        - Optional<ZonedDateTime> getNextDateTime()
    }
    TimeSeries --|> UniqueEntity
    TimeSeries "1" *-- "n" Entry
    
    class IndividualTimeSeries<V extends Value> {
        - Map<ZonedDateTime, TimeBasedValue<V>> timeToValue
    }
    IndividualTimeSeries --|> TimeSeries: <<bind>>:TimeBasedValue<V>
    
    abstract class RepetitiveTimeSeries<E extends TimeSeriesEntry<V>, V extends Value> {
        - calc(ZonedDateTime): T
    }
    RepetitiveTimeSeries --|> TimeSeries
    
    class LoadProfileInput {
        - type: StandardLoadProfile
        - dayOfWeekToHourlyValues: Map<DayOfWeek, Map<Integer, PValue>>
    }
    LoadProfileInput --|> RepetitiveTimeSeries
    LoadProfileInput *-- StandardLoadProfile

    abstract class TimeSeriesEntry <V extends Value> {
        - value: V
    }
    TimeSeriesEntry --|> UniqueEntity
    TimeSeriesEntry *-- Value

    abstract class TimeBasedValue<V extends Value>{
        - time: ZonedDateTime
    }
    TimeBasedValue --|> TimeSeriesEntry
    TimeBasedValue ..|> Comparable: <<bind>>:<TimeBasedValue>

    class LoadProfileEntry {
        - dayOfWeek: DayOfWeek
        - quarterHourOfDay: int
    }
    LoadProfileEntry --|> TimeSeriesEntry: <<bind>>:PValue
}

interface Operable {
    + inOperation: Boolean
}
Operable --|> NestedEntity

abstract class AssetInput {
    - id: String
    - operationTime: OperationTime
    - operator: OperatorInput
}
AssetInput --|> InputEntity
AssetInput ..|> Operable

abstract class SystemParticipantInput {
    - node: NodeInput
    - qCharacteristics: ReactivePowerCharacteristicInput
}
SystemParticipantInput --|> AssetInput
SystemParticipantInput ..|> HasNodes

class OperatorInput {
    + name: String
}
OperatorInput --|> InputEntity

abstract class ConnectorInput {
    + nodeA: NodeInput
    + nodeB: NodeInput
    + parallelDevices: Integer
}
ConnectorInput --|> AssetInput
ConnectorInput ..|> HasNodes

class CharacteristicCoordinate <A extends Quantity<A>, O extends Quantity<O>> {
    - x: ComparableQuantity<A>
    - y: ComparableQuantity<O>
    + deSerialize(Int): String
}
CharacteristicCoordinate ..|> Comparable

abstract class CharacteristicInput <A extends Quantity<A>, O extends Quantity<O>> {
    - characteristicPrefix: String
    - decimalPlaces: int
    - points: SortedSet<CharacteristicCoordinate>
    + deSerialize(): String
    + {static} buildStartingRegex(String): String
    - extractCoordinateList(String): String
    - buildCoordinatesFromString(String, Unit<A>, Unit<O>): SortedSet<CharacteristicCoordinate<A, O>>
}
CharacteristicInput "1" *-- "n" CharacteristicCoordinate

class WecCharacteristicInput {
}
WecCharacteristicInput --|> CharacteristicInput: <<bind>>A::Power,O::Dimensionless

class EvCharacteristicInput {
}
EvCharacteristicInput --|> CharacteristicInput: <<bind>>A::Speed,O::Dimensionless

class OlmCharacteristicInput {
    + {static} CONSTANT_CHARACTERISTIC: OlmCharacteristicInput
}
OlmCharacteristicInput --|> CharacteristicInput: <<bind>>A::Speed,O::Dimensionless

abstract class ReactivePowerCharacteristic {
    + {static} parse(String): ReactivePowerCharacteristic
}
ReactivePowerCharacteristic --|> CharacteristicInput: <<bind>>A::Dimensionless,O::Dimensionless

class CosPhiFixed {
    + {static} CONSTANT_CHARACTERISTIC: CosPhiFixed
}
CosPhiFixed --|> ReactivePowerCharacteristic

class CosPhiP {
    + {static} CONSTANT_CHARACTERISTIC: CosPhiP
}
CosPhiP --|> ReactivePowerCharacteristic

class QV {
    + {static} CONSTANT_CHARACTERISTIC: QV
}
QV --|> ReactivePowerCharacteristic: <<bind>>A::Power

abstract class AssetTypeInput {
    + id: String
}
AssetTypeInput --|> InputEntity

abstract class SystemParticipantTypeInput {
    - capex: ComparableQuantity<Currency> [€]
    - opex: ComparableQuantity<EnergyPrice> [€/MWh]
    - sRated: ComparableQuantity<Power> [kVA]
    - cosphiRated: Double
}
SystemParticipantTypeInput --|> AssetTypeInput



class BmTypeInput {
   - capex: ComparableQuantity<Currency> [€]
   - opex: ComparableQuantity<EnergyPrice> [€/MWh]
   - cosphiRated: double
   - sRated: ComparableQuantity<Power> [kVA]
   - etaConv: ComparableQuantity<Dimensionless> [%]
   - loadGradient: ComparableQuantity<DimensionlessRate> [%/h]
}
BmTypeInput --|> SystemParticipantTypeInput

class ChpTypeInput {
    - capex: ComparableQuantity<Currency> [€]
    - opex: ComparableQuantity<EnergyPrice> [€/MWh]
    - cosphiRated: double
    - pThermal: ComparableQuantity<Power> [KW]
    - etaEl: ComparableQuantity<Dimensionless> [%]
    - etaTh: ComparableQuantity<Dimensionless> [%]
    - pOwn: ComparableQuantity<Power> [kW]
    - thermalStorage: ThermalStorageInput
 }
ChpTypeInput --|> SystemParticipantTypeInput

class EvTypeInput {
    - capex: ComparableQuantity<Currency> [€]
    - opex: ComparableQuantity<EnergyPrice> [€/MWh]
    - cosphiRated: double
    - eStorage: ComparableQuantity<Energy> [kWh]
    - sRated: ComparableQuantity<Power> [kVA]
    - eCons: ComparableQuantity<SpecificEnergy> [kWh/km]
}
EvTypeInput --|> SystemParticipantTypeInput


class HpTypeInput {
    - capex: ComparableQuantity<Currency> [€]
    - opex: ComparableQuantity<EnergyPrice> [€/MWh]
    - cosphiRated: double
    - sRated: ComparableQuantity<Power> [kVA]
    - pThermal: ComparableQuantity<Power> [kW]
}
HpTypeInput --|> SystemParticipantTypeInput


class StorageTypeInput {
    - capex: ComparableQuantity<Currency> [€]
- opex: ComparableQuantity<EnergyPrice> [€/MWh]
- cosphiRated: double
- sRated: ComparableQuantity<Power> [kVA]
    - activePowerGradient: ComparableQuantity<DimensionlessRate>
    - pMax: ComparableQuantity<Power> [kW]
    - eta: ComparableQuantity<Dimensionless> [%]
    - eStorage: ComparableQuantity<Energy> [kWh]
    - dod: ComparableQuantity<Dimensionless> [%]
    - lifeTime: ComparableQuantity<Time> [ms]
    - lifeCycle: Integer
}
StorageTypeInput --|> SystemParticipantTypeInput

class WecTypeInput {
    - rotorArea: ComparableQuantity<Area> [m²]
    - hubHeight: ComparableQuantity<Length> [m]
    - etaConv: ComparableQuantity<Dimensionless> [%]
    - cpCharacteristic: WecCharacteristicInput
}
WecTypeInput --|> SystemParticipantTypeInput


class LineTypeInput {
    + r: ComparableQuantity<SpecificResistance> (Ohm/km)
    + x: ComparableQuantity<SpecificResistance> (Ohm/km)
    + g: ComparableQuantity<SpecificConductance> (µS/km)
    + b: ComparableQuantity<SpecificConductance> (µS/km)
    + iMax: ComparableQuantity<ElectricCurrent> (A)
    + vRated: ComparableQuantity<ElectricPotential> (V)
    + olmChar: Optional<String>
}
LineTypeInput --|> AssetTypeInput

class Transformer2WTypeInput {
    + sRated: ComparableQuantity<Power> (MVA)
    + vRatedA: ComparableQuantity<ElectricPotential> (kV)
    + vRatedB: ComparableQuantity<ElectricPotential> (kV)
    + rSc: ComparableQuantity<ElectricalResistance> (Ohm)
    + xSc: ComparableQuantity<ElectricalResistance> (Ohm)
    + gM: ComparableQuantity<ElectricalConductance> (nS)
    + bM: ComparableQuantity<ElectricalConductance> (nS)
    + dV: ComparableQuantity<Dimensionless> (%)
    + dPhi: ComparableQuantity<Angle> (Degrees)
    + tapSide: Boolean
    + tapNeutr: Integer
    + tapMin: Integer
    + tapMax: Integer
}
Transformer2WTypeInput --|> AssetTypeInput

class Transformer3WTypeInput {
    + vRatedA: ComparableQuantity<ElectricPotential> (kV)
    + vRatedB: ComparableQuantity<ElectricPotential> (kV)
    + vRatedC: ComparableQuantity<ElectricPotential> (kV)
    + rScA: ComparableQuantity<ElectricalResistance> (Ohm)
    + rScB: ComparableQuantity<ElectricalResistance> (Ohm)
    + rScC: ComparableQuantity<ElectricalResistance> (Ohm)
    + xScA: ComparableQuantity<ElectricalResistance> (Ohm)
    + xScB: ComparableQuantity<ElectricalResistance> (Ohm)
    + xScC: ComparableQuantity<ElectricalResistance> (Ohm)
    + gM: ComparableQuantity<ElectricalConductance> (nS)
    + bM: ComparableQuantity<ElectricalConductance> (nS)
    + sRatedA: ComparableQuantity<Power> (MVA)
    + sRatedB: ComparableQuantity<Power> (MVA)
    + sRatedC: ComparableQuantity<Power> (MVA)
    + dV: ComparableQuantity<Dimensionless> (%)
    + dPhi: ComparableQuantity<Angle> (Degrees)
    + tapNeutr: Integer
    + tapMin: Integer
    + tapMax: Integer
}
Transformer3WTypeInput --|> AssetTypeInput

class RandomLoadParameter {
    + quarterHour: Integer
    + kWd: Double
    + kSa: Double
    + kSu: Double
    + myWd: Double
    + mySa: Double
    + mySu: Double
    + sigmaWd: Double
    + sigmaSa: Double
    + sigmaSu: Double
}
RandomLoadParameter --|> InputEntity

'extractor interface information

interface NestedEntity

interface HasNodes
HasNodes --|> NestedEntity

interface HasType
HasType --|> NestedEntity

interface HasLine
HasLine --|> NestedEntity

interface HasBus
HasBus --|> NestedEntity

class FixedFeedInInput {
    - sRated: ComparableQuantity<Power> [kVA]
    - cosphiRated: double
}
FixedFeedInInput --|> SystemParticipantInput

class PvInput {
    - sRated: ComparableQuantity<Power> [kVA]
    - cosphiRated: double
    - azimuth: ComparableQuantity<Angle> [Degrees]
    - solarHeight: ComparableQuantity<Angle> [Degrees]
    - etaConv: ComparableQuantity<Dimensionless> [%]
    - albedo: Double
    - kG: Double
    - kT: Double
    - marketReaction: Boolean
}
PvInput --|> SystemParticipantInput

class WecInput{
    - type: WecTypeInput
    - marketReaction: Boolean
}
WecInput --|> SystemParticipantInput
WecInput ..|> HasType

class ChpInput {
    - type: ChpTypeInput
    - marketReaction: Boolean
}
ChpInput --|> SystemParticipantInput
ChpInput ..|> HasType

class BmInput {
    - type: BmTypeInput
    - sRated: ComparableQuantity<Power> [KW]
    - feedInTariff: ComparableQuantity<SpecificCurrency> [€/kWh]
    - marketReaction: Boolean
    - costControlled: Boolean
}
BmInput --|> SystemParticipantInput
BmInput ..|> HasType

class EvInput {
    - type: EvTypeInput
}
EvInput --|> SystemParticipantInput
EvInput ..|> HasType

class LoadInput {
    - scenario: String
    - sRated: ComparableQuantity<Power> [kVA]
    - eConsAnnual: ComparableQuantity<Energy> [kWh]
    - dsm: Boolean
}
LoadInput --|> SystemParticipantInput

class StorageInput {
    - type: StorageTypeInput
    - behaviour: String
}
StorageInput --|> SystemParticipantInput
StorageInput ..|> HasType

class HpInput {
    - type: HpTypeInput
}
HpInput --|> SystemParticipantInput
HpInput ..|> HasType

abstract class ThermalUnitInput {
 - uuid: UUID
 - bus: ThermalBusInput
}
ThermalUnitInput --|> AssetInput
ThermalUnitInput ..|> HasBus

class ThermalBusInput {
}
ThermalBusInput --|> AssetInput

abstract class ThermalSinkInput {
}
ThermalSinkInput --|> ThermalUnitInput

class ThermalHouseInput {
 - ethCapa: ComparableQuantity<HeatCapacity> [kWh / K]
 - ethLosses: ComparableQuantity<ThermalConductance> [kW / K]
}
ThermalHouseInput --|> ThermalSinkInput

abstract class ThermalStorageInput {
}
ThermalStorageInput --|> ThermalUnitInput

class CylindricalStorageInput {
  - storageVolumeLvl: ComparableQuantity<Volume>
  - storageVolumeLvlMin: ComparableQuantity<Volume>
  - inletTemp: ComparableQuantity<Temperature>
  - returnTemp: ComparableQuantity<Temperature>
  - c: ComparableQuantity<SpecificHeatCapacity>
}
CylindricalStorageInput --|> ThermalStorageInput

class MeasurementUnitInput {
    + node: NodeInput
    + vMag: Boolean [default f]
    + vAng: Boolean [default f]
    + p: Boolean [default f]
    + q: Boolean [default f]
}
MeasurementUnitInput --|> AssetInput
MeasurementUnitInput ..|> HasNodes

class NodeInput {
    + vTarget: ComparableQuantity<Dimensionless> (pU)
    + vRated: ComparableQuantity<ElectricPotential> (kV)
    + slack: Boolean
    + geoPosition: Point
    + voltLvl: VoltageLevel
    + subnet: Integer
}
NodeInput --|> AssetInput

class EvcsInput {
???
}
EvcsInput --|> AssetInput

class LineInput {
    - type: LineTypeInput
    - length: ComparableQuantity<Length> (km)
    - amount: Integer
    - olm: OlmCharacteristicInput
    - geoPosition: LineString
}
LineInput --|> ConnectorInput
LineInput ..|> HasType

class SwitchInput {
    + closed: Boolean
}
SwitchInput --|> ConnectorInput

abstract TransformerInput {
    + tapPos: Integer
    + amount: Integer
    + autoTap: Boolean
}
TransformerInput --|> ConnectorInput

class Transformer2WInput {
    + type: Transformer2WTypeInput
}
Transformer2WInput --|> TransformerInput
Transformer2WInput ..|> HasType

class Transformer3WInput {
    + nodeC: NodeInput
    + type: Transformer3WTypeInput
}
Transformer3WInput --|> TransformerInput
Transformer3WInput ..|> HasType

abstract class GraphicInput {
    + graphicLayer: String
    + path: LineString
}
GraphicInput --|> InputEntity

class NodeGraphicInput {
    + node: NodeInput
    + point: Point
}
NodeGraphicInput --|> GraphicInput
NodeGraphicInput ..|> HasNodes

class LineGraphicInput {
    + line: LineInput
}
LineGraphicInput --|> GraphicInput
LineGraphicInput ..|> HasLine

interface VoltageLevel

enum GermanVoltageLevel {
    HoeS,
    HS,
    MS,
    NS
}
GermanVoltageLevel ..|> VoltageLevel

@enduml